fn main() {
    let input = [
        Move::R(4),
        Move::R(3),
        Move::L(3),
        Move::L(2),
        Move::L(1),
        Move::R(1),
        Move::L(1),
        Move::R(2),
        Move::R(3),
        Move::L(5),
        Move::L(5),
        Move::R(4),
        Move::L(4),
        Move::R(2),
        Move::R(4),
        Move::L(3),
        Move::R(3),
        Move::L(3),
        Move::R(3),
        Move::R(4),
        Move::R(2),
        Move::L(1),
        Move::R(2),
        Move::L(3),
        Move::L(2),
        Move::L(1),
        Move::R(3),
        Move::R(5),
        Move::L(1),
        Move::L(4),
        Move::R(2),
        Move::L(4),
        Move::R(3),
        Move::R(1),
        Move::R(2),
        Move::L(5),
        Move::R(2),
        Move::L(189),
        Move::R(5),
        Move::L(5),
        Move::R(52),
        Move::R(3),
        Move::L(1),
        Move::R(4),
        Move::R(5),
        Move::R(1),
        Move::R(4),
        Move::L(1),
        Move::L(3),
        Move::R(2),
        Move::L(2),
        Move::L(3),
        Move::R(4),
        Move::R(3),
        Move::L(2),
        Move::L(5),
        Move::R(4),
        Move::R(5),
        Move::L(2),
        Move::R(2),
        Move::L(1),
        Move::L(3),
        Move::R(3),
        Move::L(4),
        Move::R(4),
        Move::R(5),
        Move::L(1),
        Move::L(1),
        Move::R(3),
        Move::L(5),
        Move::L(2),
        Move::R(76),
        Move::R(2),
        Move::R(2),
        Move::L(1),
        Move::L(3),
        Move::R(189),
        Move::L(3),
        Move::L(4),
        Move::L(1),
        Move::L(3),
        Move::R(5),
        Move::R(4),
        Move::L(1),
        Move::R(1),
        Move::L(1),
        Move::L(1),
        Move::R(2),
        Move::L(4),
        Move::R(2),
        Move::L(5),
        Move::L(5),
        Move::L(5),
        Move::R(2),
        Move::L(4),
        Move::L(5),
        Move::R(4),
        Move::R(4),
        Move::R(5),
        Move::L(5),
        Move::R(3),
        Move::L(1),
        Move::L(3),
        Move::L(1),
        Move::L(1),
        Move::L(3),
        Move::L(4),
        Move::R(5),
        Move::L(3),
        Move::R(5),
        Move::R(3),
        Move::R(3),
        Move::L(5),
        Move::L(5),
        Move::R(3),
        Move::R(4),
        Move::L(3),
        Move::R(3),
        Move::R(1),
        Move::R(3),
        Move::R(2),
        Move::R(2),
        Move::L(1),
        Move::R(1),
        Move::L(3),
        Move::L(3),
        Move::L(3),
        Move::L(1),
        Move::R(2),
        Move::L(1),
        Move::R(4),
        Move::R(4),
        Move::L(1),
        Move::L(1),
        Move::R(3),
        Move::R(3),
        Move::R(4),
        Move::R(1),
        Move::L(5),
        Move::L(2),
        Move::R(2),
        Move::R(3),
        Move::R(2),
        Move::L(3),
        Move::R(4),
        Move::L(5),
        Move::R(1),
        Move::R(4),
        Move::R(5),
        Move::R(4),
        Move::L(4),
        Move::R(1),
        Move::L(3),
        Move::R(1),
        Move::R(3),
        Move::L(2),
        Move::L(3),
        Move::R(1),
        Move::L(2),
        Move::R(3),
        Move::L(3),
        Move::L(1),
        Move::L(3),
        Move::R(4),
        Move::L(4),
        Move::L(5),
        Move::R(3),
        Move::R(5),
        Move::R(4),
        Move::R(1),
        Move::L(2),
        Move::R(3),
        Move::R(5),
        Move::L(5),
        Move::L(4),
        Move::L(1),
        Move::L(1),
    ];

    let mut pos = Position {
        d: Direction::North,
        x: 0,
        y: 0,
    };

    for m in input {
        pos = make_move(m, pos)
    }

    println!("Answer is {}", pos.x.abs() + pos.y.abs())
}

enum Move {
    L(i32),
    R(i32),
}

enum Direction {
    North,
    East,
    West,
    South,
}

struct Position {
    d: Direction,
    x: i32,
    y: i32,
}

fn make_move(m: Move, p: Position) -> Position {
    match m {
        Move::L(n) => match p.d {
            Direction::North => Position {
                d: Direction::West,
                x: p.x - n,
                y: p.y,
            },
            Direction::East => Position {
                d: Direction::North,
                x: p.x,
                y: p.y + n,
            },
            Direction::West => Position {
                d: Direction::South,
                x: p.x,
                y: p.y - n,
            },
            Direction::South => Position {
                d: Direction::East,
                x: p.x + n,
                y: p.y,
            },
        },
        Move::R(n) => match p.d {
            Direction::North => Position {
                d: Direction::East,
                x: p.x + n,
                y: p.y,
            },
            Direction::East => Position {
                d: Direction::South,
                x: p.x,
                y: p.y - n,
            },
            Direction::West => Position {
                d: Direction::North,
                x: p.x,
                y: p.y + n,
            },
            Direction::South => Position {
                d: Direction::West,
                x: p.x - n,
                y: p.y,
            },
        },
    }
}
